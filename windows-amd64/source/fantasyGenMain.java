/* autogenerated by Processing revision 1292 on 2023-05-19 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class fantasyGenMain extends PApplet {

/*******************************************************************************************************************************************************************************************
---- fantasyGenMain - Main File ----

// System Functions
- void setup()
- void draw()

*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/*************************
---- System Functions ----
*/////////////////////////


public void setup() {
  // --- System / Canvas Setup ---
  println("-----------------------------");
  println("-- SYSTEM Startup...");
  println("-----------------------------");
  
  /* size commented out by preprocessor */;                                          // Canvas Size - Image is downscaled to size this resolution
  background(deepWaterCol);                                  // Default Background - Colour of deep water used for uniform scheme
  
  drawFont = loadFont("fonts/Chiller-Regular-48.vlw");
  textFont(drawFont, 48);
  textAlign(CENTER, CENTER);                                 // Text Alignment - Defaulted to centre alignment
  textSize(24);                                              // Text Size - Defaulted to 24pt
  noStroke();                                                // Disables Default Stroke/Outline
  
  BG = loadImage("images/background.jpg");                   // Background Blend Image

  // --- noiseMap Setup ---
  noiseMap = new float[mapWidth][mapHeight];                 // noiseMap - Used for terrain and elevation with Perlin noise
  
  // --- Generative Graphics Setup ---
  mountains = new ArrayList<mountainGen>();                  // mountainGen - Mountains Array
  trees = new ArrayList<treeGen>();                          // treeGen - Trees Array
  
  terrain = createGraphics(mapWidth, mapHeight);             // PGraphics Definition - Terrain
  terrainOutline = createGraphics(mapWidth, mapHeight);      // PGraphics Definition - Terrain Outline
  shallowWater = createGraphics(mapWidth, mapHeight);        // PGraphics Definition - Shallow Water (Coast border)
  deepSea = createGraphics(mapWidth, mapHeight);             // PGraphics Definition - Deep Sea
  dangerousSea = createGraphics(mapWidth, mapHeight);        // PGraphics Definition - Dangerous Sea
 
  // -- Race Type Graphics Setup
  humanInfoImg = loadImage("images/lore-images/races/humanInfo.png"); 
  humanImage = loadImage("images/lore-images/races/human.jpg");
  
  dwarfImage = loadImage("images/lore-images/races/dwarf.jpg");
  dwarfInfoImg = loadImage("images/lore-images/races/dwarfInfo.png");
  
  elfImage = loadImage("images/lore-images/races/elf.jpg");
  elfInfoImg = loadImage("images/lore-images/races/elfInfo.png");
  
  halflingImage = loadImage("images/lore-images/races/halfling.jpg");
  halflingInfoImg = loadImage("images/lore-images/races/halflingInfo.png");
  
  // -- UI Graphics Setup --
  loadingImage = loadImage("images/ui-images/loading-image.jpg");
  borderBackground = loadImage("images/ui-images/border.jpg");
  nameBanner = loadImage("images/ui-images/nameBanner.png");
  footerBanner = loadImage("images/ui-images/footerBanner.png");
  
  zoneNameBorder = loadImage("images/ui-images/zoneName.jpg");
  ruinsBG = loadImage("images/ui-images/ruinsName.jpg");  
  loreBorder = loadImage("images/ui-images/loreArea.png");   
  
  // -- Mountain Graphics Setup --
  smallMountain1 = loadImage("images/mountain-images/small/small_mountain1.png");
  smallMountain2 = loadImage("images/mountain-images/small/small_mountain2.png");
  smallMountain3 = loadImage("images/mountain-images/small/small_mountain3.png");
  
  mediumMountain1 = loadImage("images/mountain-images/medium/medium_mountain1.png");
  mediumMountain2 = loadImage("images/mountain-images/medium/medium_mountain2.png");
  mediumMountain3 = loadImage("images/mountain-images/medium/medium_mountain3.png");
  
  largeMountain1 = loadImage("images/mountain-images/large/large_mountain1.png");  
  largeMountain2 = loadImage("images/mountain-images/large/large_mountain2.png");  
  largeMountain3 = loadImage("images/mountain-images/large/large_mountain3.png");  
  largeMountain4 = loadImage("images/mountain-images/large/large_mountain4.png");  
  
  peakMountain1 = loadImage("images/mountain-images/peak/peak_mountain1.png");  
  peakMountain2 = loadImage("images/mountain-images/peak/peak_mountain2.png"); 
  
  // -- Tree Graphics Setup --
  smallTree1 = loadImage("images/tree-images/small/tree_small1.png");
  smallTree2 = loadImage("images/tree-images/small/tree_small2.png");
  smallTree3 = loadImage("images/tree-images/small/tree_small3.png");
  
  mediumTree1 = loadImage("images/tree-images/medium/tree_medium1.png");
  //mediumTree1 = loadImage("tree_medium1.png");
  //mediumTree1 = loadImage("tree_medium1.png");
  
  largeTree1 = loadImage("images/tree-images/large/tree_large1.png");  
  
  // -- Small Zone Graphics Setup -- 
  watchTower = loadImage("images/zone-images/smallZones/lookoutTower.png");
  guardTower = loadImage("images/zone-images/smallZones/guardTower.png");
  wizardTower = loadImage("images/zone-images/smallZones/wizardTower.png");
  smallChurch = loadImage("images/zone-images/smallZones/church.png");
  
  // -- Medium Zone Graphics Setup -- 
  mediumVillage1 = loadImage("images/zone-images/mediumZones/medium-village1.png");
  mediumVillage2 = loadImage("images/zone-images/mediumZones/medium-village2.png");
  mediumVillage3 = loadImage("images/zone-images/mediumZones/medium-village3.png");
  
  // -- Large Zone Graphics Setup -- 
  dwarfTown = loadImage("images/zone-images/largeZones/dwarf-town.png");
  elfTown = loadImage("images/zone-images/largeZones/elf-town.png");
  halflingTown = loadImage("images/zone-images/largeZones/halfling-town.png");
  humanTown = loadImage("images/zone-images/largeZones/human-town.png");
  
  // -- Ruins Graphics Setup --
  ruins1 = loadImage("images/zone-images/smallZones/ruins/ruins1.png");
  ruins2 = loadImage("images/zone-images/smallZones/ruins/ruins2.png");
  ruins3 = loadImage("images/zone-images/smallZones/ruins/ruins3.png");
  ruins4 = loadImage("images/zone-images/smallZones/ruins/ruins4.png");
  ruins5 = loadImage("images/zone-images/smallZones/ruins/ruins5.png");

  // --- Terrain Method Calls ---
  getElevationLimits();              // Calculate elevation limits from noiseMap
  getThresholds();                   // Calculate thresholds based on elevation limits
  
  drawTerrain();                     // Main function call for drawing terrain
  isTerrainDrawn = true;             // Boolean flag for successful terrain drawing
  
  selectStrategicPoints();           // Called prior to map type calculation to determine amount of strategic points on map for towns, cities and landmarks
  
  generateMapType();                 // Determines populace and hostility of map
  
  drawStrategicPoints(raceType);     // Draws race specific landmarks and towns depending on generateMapType outcome
  
  getLandName();                     // Ensure land name is generated by calling external function
  getSeaName();                      // Ensure sea name is generated by calling external function
  
  generateLore(hostility);                    // Call generate lore
  // --- Post-Run Output Log ---
  println("-----------------------------"); 
  println("-- SYSTEM: Successful Run!");
  println("-----------------------------\n");

  println("---------- Debug ------------");
  
  println("Elevation Max: " + terrainMaxElevation);
  println("Elevation Min: " + terrainMinElevation);
  println("LM THRESH: " + largeMountainThreshold);
  println("MM THRESH: " + mediumMountainThreshold);
  println("SM THRESH: " + smallMountainThreshold);
  println("Noise Min: " + noiseMin);
  println("Noise Min * 1.1: " + noiseMin * 1.1f);
  println("\n-- Mountain Debug --");
  
  println("Large Mountain Chance: " + largeMountainChance);
  println("Medium Mountain Chance: " + mediumMountainChance);
  println("Small Mountain Chance: " + smallMountainChance);
  
  println("\n-- Tree Debug --");
  println("Trees Spawned: " + trees.size());
  println("Mountains Spawned: " + mountains.size());
  
  println("\n-- Terrain Debug --");
  println("Sea Map Size: " + seaMap.size());
  println("Terrain Map Size: " + terrainMap.size());
  
  println("\n-- Zone Debug --");
  
  println("Final Strategic Points Size: " + strategicZones.size());
  
  println("Small Zones Max: " + maxSmallZones);
  println("Medium Zones Max: " + maxMediumZones);
  println("Large Zones Max: " + maxLargeZones);
  
  println("Small Zones Count: " + smallZoneCount);
  println("Medium Zones Count: " + mediumZoneCount);
  println("Large Zones Count: " + largeZoneCount);
  
  println("\n-- Populace Debug --");
  
  println("Populace Type: " + raceType);
  println("Hostility Setting: " + hostility);
  println("Hostility Threshold: " + hostilityThreshold);
  println("Ruins Count: " + ruinsCount);
  println("Zone Null Count: " + zoneNullCount);
  println(introString1);
}


/***********************
---- Draw Functions ----
*///////////////////////


// Main Draw - Processing Function Used for Draw 
public void draw() {
  // -- Sea & Shallow Border Draw --
  image(deepSea, 0, 100, mapWidth, mapHeight);
  image(dangerousSea, 0, 100, mapWidth, mapHeight);
  image(shallowWater, 0, 100, mapWidth, mapHeight);
 
  // -- Terrain & Outline Draw --
  image(terrainOutline, 0, 100, mapWidth, mapHeight);
  image(terrain, 0, 100, mapWidth, mapHeight);
  
  // -- Tree Drawing --
  for (treeGen tree : trees) {
    image(tree.image, tree.position.x - 5, tree.position.y + 90);
  }
  
  // -- Mountain Drawing --
  for (mountainGen mountain : mountains) {
    image(mountain.image, mountain.position.x - 10, mountain.position.y + 90);
  } 

  // -- Map Blending --
  blendMode(MULTIPLY);
  image(BG, 0, 99, width, 721);
  blendMode(BLEND);  

  // -- Banner Definitions --
  // Header declaration
  image(nameBanner, 0, 0, width, 100);
  textFont(drawFont, 38);
  text(landName, 770, 49);
  fill(0);
  
  // -- Footer Declaration & Blending -- 
  image(footerBanner, 0, 820, width, 180);

  // -- Race Information -- 
  image(currentRaceImage, 14, 837, 260, 146);
  image(currentRaceInfoImage, 285, 837, 220, 146);  
  
  // -- Lore Image Generation --
  image(loreBorder, 546, 830, 630, 160);  
  
  // -- Text Generation --
  text("Area Attitude: " + (hostility ? "hostile" : "friendly"), 687, 865); 
  text("Area Population: " + (round(PApplet.parseInt(terrainMap.size() * 0.005f))), 685, 910); 
  text("POI Count: " + totalZones, 647, 955); 
  
  textSize(24);  
  text(introString1, 985, 860);
  text(introString2, 985, 880);
  text(introString3, 985, 920);
  text(introString4, 985, 940);
  text(introString5, 985, 965);
}
/***************************************************************************************************

---- System Definitions ----

*///////////////////////////////////////////////////////////////////////////////////////////////////

// --- Section/Terrain Definitions ---
PGraphics terrain;                      // PGraphics Object - General Terrain
PGraphics terrainOutline;               // PGraphics Object - Terrain Outline 
PGraphics shallowWater;                 // PGraphics Object - Shallow Water (Coast & Sea Spacer)
PGraphics deepSea;                      // PGraphics Object - Deep Sea (Water Area/Sea)

PGraphics dangerousSea;                 // PGraphics Object - Dangerous Sea (Deep Sea Danger Areas)
PGraphics dangerousLand;                // PGraphics Object - Dangerous Land (Land Danger Areas)

// --- System Variables ---
int searchRadius = 10;                  // int - Tile search radius ?????????
boolean isTerrainDrawn = false;         // Boolean - Terrain draw check

// -- Populace Outlook Variables -- 
boolean hostility;                      // Populace Hostility - Determined by ruins threshold fitness value (hostilityThreshold)
int hostilityThreshold;                 // Int - Ruins fitness value
int raceType;                           // Int - Race Type (1 - Human, 2 - Halfing, 3 - Dwarf, 4 - Elf)

// --- Canvas Variables ---
int mapWidth = 1200;                    // Int - Map Generation Height (Seperate to canvas)
int mapHeight = 720;                    // Int - Map Generation Width (Seperate to canvas)

PImage BG;                              // PImage - Background Image for Blending
PImage ruinsBG;                         // PImage - Ruins background
PFont drawFont;                         // PFont - Main drawing font for map title and lore

// --- Border Images ---
PImage borderBackground;                // PImage - Background image for border - blending
PImage loadingImage;                    // PImage - Overlay image for loading - awaiting likeness prompt for lore gen
PImage nameBanner;                      // PImage - Header banner used for map name, distance & icon key
PImage footerBanner;                    // PImage - Footer banner outline
PImage loreBorder;                      // PImage - Lore area border

// --- Race Type Images / Variables ---
PImage currentRaceImage;                // PImage - Current Race Image
PImage currentRaceInfoImage;            // PImage - Current Race Info Image

PImage humanImage;                      // PImage - Human race image
PImage humanInfoImg;                    // PImage - Human info image

PImage dwarfImage;                      // PImage - Dwarf race image
PImage dwarfInfoImg;                    // PImage - Dwarf info image

PImage elfImage;                        // PImage - Elf race image
PImage elfInfoImg;                      // PImage - Elf info image

PImage halflingImage;                   // PImage - Halfling race image
PImage halflingInfoImg;                 // PImage - Halfling info image

// -- Intro String Definitions --
String introString1;                    // String - Intro String 1
String introString2;                    // String - Intro String 1
String introString3;                    // String - Intro String 1
String introString4;                    // String - Intro String 1
String introString5;                    // String - Intro String 1

// -- Small Zone Images --
PImage ruins1;                          // PImage - Ruins Image 1
PImage ruins2;                          // PImage - Ruins Image 2
PImage ruins3;                          // PImage - Ruins Image 3
PImage ruins4;                          // PImage - Ruins Image 4
PImage ruins5;                          // PImage - Ruins Image 5

PImage watchTower;                      // PImage - Ruins Image 1
PImage guardTower;                      // PImage - Ruins Image 1
PImage wizardTower;                     // PImage - Ruins Image 1
PImage smallHouse;                      // PImage - Ruins Image 1
PImage smallChurch;                     // PImage - Ruins Image 1

// -- Medium Zone Images --
PImage mediumVillage1;                  // PImage - Medium Village 1
PImage mediumVillage2;                  // PImage - Medium Village 2
PImage mediumVillage3;                  // PImage - Medium Village 3

// --- Large Zone Images ---
PImage dwarfTown;                       // PImage - Dwarf capital
PImage halflingTown;                    // PImage - Halfling capital
PImage humanTown;                       // PImage - Human capital
PImage elfTown;                         // PImage - Elf capital

// --- Zone Generation Defininitions ---
int strategicPointSize = 30;                            // Int - Point Size
int minDistanceBetweenPoints = strategicPointSize * 3;  // Int - Min distance between points

PImage zoneNameBorder;                                  // PImage - Border for zone name tag

ZoneGen largeZone;                           // ZoneGen - Large zone
int zoneNullCount;                           // Int - Zone debug check
int totalZones;                              // Int - Total zones count

int smallZoneCount = 0;                      // Int - Small zone count
int mediumZoneCount = 0;                     // Int - Medium zone count
int largeZoneCount = 0;                      // Int - Large zone count

int maxSmallZones = round(random(10, 15));   // Int - Threshold for max small zones
int maxMediumZones = round(random(6, 8));    // Int - Threshold for max medium zones
int maxLargeZones = 1;                       // Int - Threshold for max large zones

int ruinsCount;                              // Int - Ruins count

int coastalZoneCount = 0;                    // Int - Coast zone count
int cityCoastProximity = 15;                 // Int - Minimum coast proximity for zone
int minimumCoastalZones = 5;                 // Int - Minimum ideal coastal zones

ArrayList<PVector> terrainMap = new ArrayList<PVector>();            // Array Def - terrainMap
ArrayList<PVector> seaMap = new ArrayList<PVector>();                // Array Def - seaMap

ArrayList<PVector> strategicPoints = new ArrayList<PVector>();       // Array Def - strategicPoints
ArrayList<PVector> finalStrategicPoints = new ArrayList<PVector>();  // Array Def - finalStrategicPoints
ArrayList<ZoneGen> strategicZones = new ArrayList<ZoneGen>();        // Array Def - strategicZones

// --- Colour Variables (Used in Map Generation & Debug)---
int landColour = color(187, 146, 96); 
int coastColour = color(175, 135, 85); 

int waterColour = color(0, 130, 130); 
int waterDebug = color(0, 140, 140);

int shallowWaterCol = color(219, 200, 179);
int deepWaterCol = color(178, 149, 117);
int dangerousWaterCol = color(160, 121, 89);

int debugColour1 = color(0, 0, 0, 100); 
int debugColour2 = color(128, 128, 128); 
int debugColour3 = color(255, 255, 255); 

// -- Zone Names --
String seaName;           // String - Sea name
String landName;          // String - Land (Map) name
String townName;          // String - Town Name

String mapType;           // String - Map Type (Races)

// -- Race Subtypes --
int commonSubType;        // Human Subtype
int halflingSubType;      // Hobbit Subtype
int dwarfSubType;         // Dwarf Subtype
int elfSubType;           // Elf Subtype

// -- Land Naming Definitions -- 
String[] landGoodPrefixes = {"Golden", "Shimmering", "Moonlit", "Pyre"};
String[] landGoodSuffixes = {"Cove", "Bay", "Sands", "Shores"};

String[] landBadPrefixes = {"Dead", "Formidable"};
String[] landBadSuffixes = {"Marshes", "Crag"};

// -- Sea Naming Definitions -- 
String[] seaGoodPrefixes = {"Tranquil", "Golden", "Plentiful", "Calm", "Resplendent", "Majestic", "Enchanting", "Serene", ""} ;
String[] seaGoodSuffixes = {"Waters", "Seas"};

String[] seaBadPrefixes = {"Cursed", "Turbulent", "Foaming", "Foul", "Torrential", "Doomed", "Overcumbent", "Destructive", "Poisoned", "Devil's", "Ravaging", "Deadly", "Wrecked"};
String[] seaBadSuffixes = {"Waters", "Seas", "Rapids", "Unknown", "Death"};

// -- Church Naming Definitions --
String[] churchGoodPrefixes = {"Holy", "Blessed", "Divine", "Revered", "Ancient"};
String[] churchGoodSuffixes = {"Church", "Site", "Grounds"};

String[] churchBadPrefixes = {"Ruined", "Profaned", "Corrupted", "Destroyed", "Cultist","Blasphemous", "Plagued", "Demonic"};
String[] churchBadSuffixes = {"Church", "Site", "Grounds", "Ruins"}; 

// -- Ruins Naming Definitions --
String[] ruinsPrefixes = {"Cursed", "Poisoned", "Forbidden", "Evil", "Ancient", "Crumbling", "Sinful", "Venomous", "Malignant", "Malefic"};
String[] ruinsSuffixes = {"Ruins", "Grounds", "Relic", "Burial Grounds", "Citadel"};

// – Watchtower Naming Definitions –
String[] towerPrefixes = {"Cursed", "Poisoned", "Forbidden", "Evil", "Ancient", "Rotten"};
String[] towerSuffixes = {"Ruins", "Grounds", "Relic", "Burial Grounds"};

// -- Common Town Combinations (Good & Bad Orientation) -- 
String[] humanGoodPrefixes = {"Green", "Dark", "Light", "Iron", "Silver", "Golden", "Copper", "Lockwood", "White", "Riven", "Storm", "Spring"};
String[] humanGoodSuffixes = {"Haven", "Gate", "Vale", "Hill", "Fort"};

String[] humanBadPrefixes = {"Forbidden", "Dark", "Cursewood", "Ghastly", "Desolate", "Forsaken","Wrecked", "Barren"};
String[] humanBadSuffixes = {"Vale", "Fell", "Hill", "Village", "Edge"};

String[] commonCoastNames = {"-On-The-Water", "-By-" + seaName, " Upon-" + seaName, };

// -- Halfing Town Combinations (Good Orientation Only) -- 
String[] halflingPrefixes = {"Brandywine", "Tookborough", "Northfarthing", "Bracegirdle", "Hardbottle", "Bullroarer", "Whitfurrow", "Withywindle", "Crickhollow"};
String[] halflingSuffixes = {"Gate", "Hill", "Village", "Hedge", "Bucks", "Grove"};

// -- Dwarf Town Combinations (Good & Cursed Orientation) -- 
String[] dwarfGoodPrefixes = {"Rock", "Iron", "Axe", "Broadaxe", "Cleaver", "Stout", "Anvil", "Deeprock", "Hammer", "Hearthstone"};
String[] dwarfGoodSuffixes = {"Isle", "Mining Town", "Ironfort", "Mining Village"};

String[] dwarfBadPrefixes = {"Fallen", "Cursed", "Overrun", "Burned"};
String[] dwarfBadSuffixes = {"Battlegrounds", "Mining Town", "Mining Village"};

String[] dwarfCoastNames = {" Crag", " Cliffhold", " Stonebay", " Ironport"};

// -- Elvish Town Combinations (Good & Cursed Orientation) -- 
String[] elfGoodPrefixes = {"Heavenly", "Serene", "Blessed", "Moonlit"};
String[] elfGoodSuffixes = {"Isle", "City", "Village"};

String[] elfBadPrefixes = {"Fallen", "Cursed", "Overrun", "Burned"};
String[] elfBadSuffixes = {"City", "Site", "Shrine"};

String[] elfCoastNames = {" Harbours", " Beaches", " Breezes", " Moonshores", " Sands"};

// --- Terrain Thresholds & Definitions ---
float terrainScale = 0.5f;                      // Float - Terrain generation limit

// --- Noise - Thresholds & Definitions ---
float[][] noiseMap;                             // Float - NoiseMap (Perlin Noise storage)

float noiseScale = 0.002f;                      // Float - Max noise generated
float noiseMin = Float.MAX_VALUE;               // Float - Min noise generated

int octaves = 6;                                // Int - Layers of noise
float persistence = 0.5f;                       // Float - Amplitude control
float lacunarity = 2.2f;                        // Float - Frequency from each successisive layer

// --- Landmark & Terrain - Thresholds & Definitions ---
float elevation;                                          // Float - Elevation store
float terrainMaxElevation = 0f;                           // Float - Max elevation generated
float terrainMinElevation = Float.MAX_VALUE;              // Float - Min elevation generated

float minElevation = 0.0f;                                // Float - Maximum elevation amount
float maxElevation = 1.0f;                                // Float - Minimum elevation amount

boolean coastal;                                          // Boolean - Coastal Check

// -- Tree Image/Type Definitions --
ArrayList<treeGen> trees;      // Array Definition - TreeGen

PImage smallTree1;             // PImage Definition - Small Tree 1
PImage smallTree2;             // PImage Definition - Small Tree 2
PImage smallTree3;             // PImage Definition - Small Tree 3

PImage mediumTree1;            // PImage Definition - Medium Tree 1
PImage mediumTree2;            // PImage Definition - Medium Tree 2
PImage mediumTree3;            // PImage Definition - Medium Tree 3

PImage largeTree1;             // PImage Definition - Large Tree 1
PImage largeTree2;             // PImage Definition - Large Tree 2
PImage largeTree3;             // PImage Definition - Large Tree 3

// -- Treeline Thresholds -- 
float maxSTOverlap = 0.6f;     // 0verlap Threshold - Small Tree
float maxSTMOverlap = 1.05f;   // 0verlap Threshold - Small Tree (Mountain Treeline Specific)
int maxSTSubtype = 3;          // Subtype Threshold - Small Tree

float maxMTOverlap = 1.0f;     // 0verlap Threshold - Medium Tree
int maxMTSubtype = 3;          // Subtype Threshold - Medium Tree

float maxLTOverlap = 1.3f;     // 0verlap Threshold - Large Tree
int maxLTSubtype = 3;          // Subtype Threshold - Large Tree

// -- Mountain Type & Array Definitions
ArrayList<mountainGen> mountains;       // ArrayList - Mountain storage for spawning

PImage peakMountain1;                    // PImage Definition - Peak Mountain 1
PImage peakMountain2;                    // PImage Definition - Peak Mountain 2 

PImage largeMountain1;                   // PImage Definition - Large Mountain 1
PImage largeMountain2;                   // PImage Definition - Large Mountain 2
PImage largeMountain3;                   // PImage Definition - Large Mountain 3
PImage largeMountain4;                   // PImage Definition - Large Mountain 4

PImage mediumMountain1;                  // PImage Definition - Medium Mountain 1 
PImage mediumMountain2;                  // PImage Definition - Medium Mountain 2
PImage mediumMountain3;                  // PImage Definition - Medium Mountain 3

PImage smallMountain1;                   // PImage Definition - Small Mountain 1
PImage smallMountain2;                   // PImage Definition - Small Mountain 2
PImage smallMountain3;                   // PImage Definition - Small Mountain 3

// -- Mountain Thresholds --
float peakMountainThreshold;            // Spawning threshold (elevation) for peak mountains
float largeMountainThreshold;           // Spawning threshold (elevation) for large mountains
float mediumMountainThreshold;          // Spawning threshold (elevation) for medium mountains
float smallMountainThreshold;           // Spawning threshold (elevation) for small mountains

float maxPMOverlap = 0.2f;              // 0verlap Threshold - Peak Mountain  
int maxPMSubtype = 2;                   // Subtype Threshold - Peak Mountain  

float maxLMOverlap = 0.6f;              // 0verlap Threshold - Large Mountain  
int maxLMSubtype = 4;                   // Subtype Threshold - Large Mountain  

float maxMMOverlap = 0.8f;              // 0verlap Threshold - Medium Mountain                 
int maxMMSubtype = 3;                   // Subtype Threshold - Medium Mountain  

float maxSMOverlap = 1.1f;              // 0verlap Threshold - Small Mountain
int maxSMSubtype = 3;                   // Subtype Threshold - Small Mountain

float peakMountainChance = 0.135f;      // Spawn Chance - Peak Mountain
float largeMountainChance = 0.13f;      // Spawn Chance - Large Mountain
float mediumMountainChance = 0.10f;     // Spawn Chance - Medium Mountain
float smallMountainChance = 0.05f;      // Spawn Chance - Small Mountain

// --- LoreGen Text Definitions
int mapLifespan = 0;                    // Int - Lifespan Default
String raceName;                        // String - Race Name
String capitalName = "";                // String - Capital city name
/*********************
---- Code Section ----
*/////////////////////

// Generate Town Names - Function for generating town names depending on the populace's hostility and race.
public String generateTownName(int raceType, boolean populaceFriendly, boolean isCoastal, boolean isChurch, boolean isRuins, boolean isTower) {
  int randPrefix, randSuffix, randCoast;
  String townName = "";
  
  // Type Check - Ruins
  if (isRuins) {
    randPrefix = (int) random(ruinsPrefixes.length);
    randSuffix = (int) random(ruinsSuffixes.length);
    
    townName = ruinsPrefixes[randPrefix] + " " + ruinsSuffixes[randSuffix];
  }
  
  // Type Check - Church
  if (isChurch) {
    randPrefix = (int) random(churchGoodPrefixes.length);
    randSuffix = (int) random(churchGoodSuffixes.length);
    
    townName = churchGoodPrefixes[randPrefix] + " " + churchGoodSuffixes[randSuffix];
  } 
  
  // Type Check - Tower
  if (isTower) {
    randPrefix = (int) random(towerPrefixes.length);
    randSuffix = (int) random(towerSuffixes.length);
    
    townName = towerPrefixes[randPrefix] + " " + towerSuffixes[randSuffix];
  }
  
  else if (isChurch && !populaceFriendly) {
    randPrefix = (int) random(churchBadPrefixes.length);
    randSuffix = (int) random(churchBadSuffixes.length);
    
    townName = churchBadPrefixes[randPrefix] + " " + churchBadSuffixes[randSuffix];
  }  
  // Check for hostility
  if (hostility) {
    
    // Race Check - Determined by generateMapType (loreGen)
    switch(raceType) {
      
      case 1:
        randPrefix = (int) random(humanGoodPrefixes.length);
        randSuffix = (int) random(humanGoodSuffixes.length);
        if (isCoastal) {
          randCoast = (int) random(commonCoastNames.length);
          townName = humanGoodPrefixes[randPrefix] + " " + humanGoodSuffixes[randSuffix] + commonCoastNames[randCoast];
        } else {
          townName = humanGoodPrefixes[randPrefix] + " " + humanGoodSuffixes[randSuffix];
        }
        break;
        
      case 2:
        randPrefix = (int) random(halflingPrefixes.length);
        randSuffix = (int) random(halflingSuffixes.length);
        if (isCoastal) {
          randCoast = (int) random(commonCoastNames.length);
          townName = halflingPrefixes[randPrefix] + " " + halflingSuffixes[randSuffix] + commonCoastNames[randCoast];
        } else {
          townName = halflingPrefixes[randPrefix] + " " + halflingSuffixes[randSuffix];
        }
        break;
        
      case 3:
        randPrefix = (int) random(dwarfGoodPrefixes.length);
        randSuffix = (int) random(dwarfGoodSuffixes.length);
        townName = dwarfGoodPrefixes[randPrefix] + " " + dwarfGoodSuffixes[randSuffix];
        break;
        
      case 4:
        randPrefix = (int) random(elfGoodPrefixes.length);
        randSuffix = (int) random(elfGoodSuffixes.length);
        townName = elfGoodPrefixes[randPrefix] + " " + elfGoodSuffixes[randSuffix];
        break;
        
      default:
        townName = "Unknown"; // ISSUE HERE
    }
  } 
  
  // Check for hostility
  else if (!hostility) {
    
    // Race Check - Determined by generateMapType (loreGen)
    switch(raceType) {
      case 1:
        randPrefix = (int) random(humanBadPrefixes.length);
        randSuffix = (int) random(humanBadSuffixes.length);
        townName = humanBadPrefixes[randPrefix] + " " + humanBadSuffixes[randSuffix];
        break;
        
      case 3:
        randPrefix = (int) random(dwarfBadPrefixes.length);
        randSuffix = (int) random(dwarfBadSuffixes.length);
        townName = dwarfBadPrefixes[randPrefix] + " " + dwarfBadSuffixes[randSuffix];
        break;
        
      case 4:
        randPrefix = (int) random(elfBadPrefixes.length);
        randSuffix = (int) random(elfBadSuffixes.length);
        townName = elfBadPrefixes[randPrefix] + " " + elfBadSuffixes[randSuffix];
        break;
        
      default:
        townName = "Unknown";
    }
  }
  return townName;
}

// Generate Map Type - Function for selecting populace type of generated map, and in extension the lore of the map
public void generateMapType() {
  hostilityThreshold = round(smallZoneCount * 0.5f);
  if (ruinsCount > hostilityThreshold) {
    hostility = true;
  }
  
  //int mapSize = terrainMap.size();
  int treesAmount = trees.size();
  int mountainsAmount = mountains.size();
  //int seaSize = seaMap.size();
  
  println("generateMapType: Selecting Type..");
  
  // Elvish Type
  if (treesAmount > 300 && mountainsAmount < 100) { 
    raceType = 4;
    raceName = "Elves";
    
    currentRaceImage = elfImage;
    currentRaceInfoImage = elfInfoImg;
  } 
  
  // Dwarvish Type
  else if (mountainsAmount > 500) {
    raceType = 3;
    raceName = "Dwarves";
    
    currentRaceImage = dwarfImage;
    currentRaceInfoImage = dwarfInfoImg;
  } 
  
  // Human/Common Type
  else if (treesAmount < 200 && mountainsAmount < 250 && mountainsAmount > 50 || treesAmount < 10 && mountainsAmount < 10) {
    raceType = 1;
    raceName = "Humans";
    
    currentRaceImage = humanImage;
    currentRaceInfoImage = humanInfoImg;
    
  } 
  
  else if (treesAmount > 200 && treesAmount < 500 && mountainsAmount < 50 && largeZoneCount == 0 || largeZoneCount == 0 && mountainsAmount < 50) {
    raceType = 2;
    raceName = "Hobbits";
    
    currentRaceImage = halflingImage;
    currentRaceInfoImage = halflingInfoImg;

  } else {
    raceType = 1;
    raceName = "Humans";
    
    currentRaceImage = humanImage;
    currentRaceInfoImage = humanInfoImg;
  }
  
  // Null Check - If the terrain isn't returning a choice under these factors, extra investigation is taken to decide orienatation and race.
  if (currentRaceImage == null) {
    int raceRandom = PApplet.parseInt(round(random(1, 2)));
    
    switch(raceRandom) {
      case 1:
        raceType = 1;
        raceName = "Humans";
        
        currentRaceImage = humanImage;
        currentRaceInfoImage = humanInfoImg;
        
        break;
      case 2:
        
        // Initial Random to Dwarf, Given Conditions
        if (mountainsAmount > 100) {
          raceType = 3;
          raceName = "Dwarves";
          
          currentRaceImage = dwarfImage;
          currentRaceInfoImage = dwarfInfoImg;
          
          dwarfSubType = 1;
          //generateDwarfLore(dwarfSubType);
        } 
        
        // Default to Human
        else {
          raceType = 1;
          raceName = "Humans";
          
          currentRaceImage = humanImage;
          currentRaceInfoImage = humanInfoImg;
        }
        break;
    }
  }
}

// Get Land Name - Function for generating land name
public void getLandName() {
  int randPrefix, randSuffix;
  
  if (hostility) {
    randPrefix = (int) random(landBadPrefixes.length);
    randSuffix = (int) random(landBadSuffixes.length);
    
    landName = landBadPrefixes[randPrefix] + " " + landBadSuffixes[randSuffix];
    
  } else if (!hostility) {
    randPrefix = (int) random(landGoodPrefixes.length);
    randSuffix = (int) random(landGoodSuffixes.length);
    
    landName = landGoodPrefixes[randPrefix] + " " + landGoodSuffixes[randSuffix];
    
  } else {
    landName = "Error Island!";
    println("getLandName: Error!");
  }
}

// Get Sea Name - Function for generating sea name
public void getSeaName() {
  int randPrefix, randSuffix;
  
  if (hostility) {
    randPrefix = (int) random(seaBadPrefixes.length);
    randSuffix = (int) random(seaBadSuffixes.length);
    
    seaName = seaBadPrefixes[randPrefix] + " " + seaBadSuffixes[randSuffix];
    
  } else if (!hostility) {
    randPrefix = (int) random(seaGoodPrefixes.length);
    randSuffix = (int) random(seaGoodSuffixes.length);
    
    seaName = seaGoodPrefixes[randPrefix] + " " + seaGoodSuffixes[randSuffix];
    
  } else {
    seaName = "Error Isles!";
    println("getSeaName: Error!");
  }
}


public void generateLore(boolean hostility) {
  mapLifespan = PApplet.parseInt(round(random(800,7000)));
  
  introString1 = ("The islands of " + landName + " are " + (hostility ? "hostile" : "friendly") + "to travellers,"); 
  introString2 = ("take that as ye will; don't go meddling. ");
  introString3 = (raceName + " inhabit these lands and they ");
  introString4 = (" have done for " + mapLifespan + " years.");
  introString5 = (capitalName + "is the Capital, keep your noses clean.");
}


/*********************
---- Code Section ----
*/////////////////////

// mountainGen - Class Definition
class mountainGen {
  PVector position;      // PVector - x, y position.
  PImage image;          // PImage - Stored image/tree type.

  mountainGen(PVector position, PImage image) {
    this.position = position;
    this.image = image;
  }
}

// Place Mountain - Function for placing mountain depending on type and available space
public void placeMountain(PImage image, float overlap, float elevation, int x, int y) {

  boolean canSpawnMountain = true;

  for (mountainGen mountain : mountains) {

    float distance = dist(x, y, mountain.position.x, mountain.position.y);
    float minDistance = (mountain.image.width + mountain.image.height) / 2 * overlap;
    if (distance < minDistance) {
      canSpawnMountain = false;
      println("MountainGen: Error! Cannot Place " + mountain.toString() + " at " + x + ", " + y + ". Distance: " + distance + " MinDistance: " + minDistance);
      break;
    }
  }
  
  // Image Manipulation (Resize: width & height & transparency
  PImage imgCopy = image.copy();
  
  float elevationCheckWidth = map(elevation, minElevation, maxElevation, 0.9f, 1.2f); 
  float elevationCheckHeight = map(elevation, minElevation, maxElevation, 0.6f, 2.3f); 
  
  int newWidth = PApplet.parseInt(imgCopy.width * elevationCheckWidth);
  int newHeight = PApplet.parseInt(imgCopy.height * elevationCheckHeight);
  int newTransparency = PApplet.parseInt(map(elevation, minElevation, maxElevation, 140, 245));
  
  imgCopy.resize(newWidth, newHeight);
  tint(255, newTransparency);
  
  // PVector Array Storage - x & y represent the related co-ordinates, z represents mountain type.
  if (canSpawnMountain ) {
    mountains.add(new mountainGen(new PVector(x, y), imgCopy));
    println("MountainGen: Successfully placed " + imgCopy.toString() + " at " + x + ", " + y);
  }
}
/***********************
---- Code Section ----
*/////////////////////

// Draw Terrain - Function for drawining initial canvas, landmasses and elevation generation
public void drawTerrain() {
  terrain.beginDraw();                 // Begins terrain draw call
  terrainOutline.beginDraw();
  shallowWater.beginDraw(); 
  deepSea.beginDraw();
  dangerousSea.beginDraw();

  for (int x = 0; x < mapWidth; x++) {
    for (int y = 0; y < mapHeight; y++) {
      
      // -- Noise Logic & Definitions --
      float noiseVal = noiseMap[x][y]; // Float - Current noiseMap Value
      float colorFactor = map(noiseVal, 0.4f, terrainScale, 0, 0.8f);
      //float colorFactorDangerous = map(noiseVal, 0.1, 0.3, 0, 1); 
      
      if (noiseMap[x][y] < noiseMin) {
        noiseMin = noiseMap[x][y]; // Update the minValue if a smaller value is found
      }
      
      /************************
      ---- Land Generation ----
      *////////////////////////
      
      if (noiseVal > terrainScale) {
        // --- Coastline Tile Distance Calculation ---
        float coastTileDistance = calculateCoastDistance(x, y);
        coastTileDistance = min(coastTileDistance, searchRadius);
        
        float coastCalcFactor = map(coastTileDistance, 0, searchRadius, 0.5f, 1);
        
        // --- Elevation Logic ---
        elevation = map(noiseVal, 0.6f, 1, minElevation, maxElevation) * coastCalcFactor;
        
        // --- Terrain Logic ---
        terrain.set(x, y, landColour);
        terrainMap.add(new PVector(x, y));
        //shallowWater.set(x, y, debugColour3); // test
        
        // --- Coastline Generation ---
        if (noiseVal < 0.51f) {
          terrain.set(x, y, coastColour);
        }
        
        if (hasWaterNeighbour(x, y, mapWidth, mapHeight)) {
          shallowWater.strokeWeight(2);
          shallowWater.stroke(shallowWaterCol); // Set shallow water color (blue with transparency)
          shallowWater.noFill();
          shallowWater.rect(x, y, 1, 1);  
          
          terrainOutline.stroke(debugColour1);     // Set Terrain outline RGBA
          terrainOutline.strokeWeight(1);        // Set Terrain outline (Stroke) thickness
          terrainOutline.noFill();                 // Disable fill - stops Terrain object being filled, but rather built upon.
          terrainOutline.rect(x, y, 1, 1);    
        } 
        
        // --- Mountain Generation ---
        
        // -- Threshold Logic
        if (elevation >= peakMountainThreshold) {
          PImage currentMountain = null;
          int subType = PApplet.parseInt(round(random(1, maxPMSubtype)));
          
          switch(subType) {
            case 1: 
              currentMountain = peakMountain1;
              break;
            case 2:
              currentMountain = peakMountain2;
              break;
          }
          
          placeMountain(currentMountain, maxPMOverlap, elevation, x, y);
          
          println("\n---------------------------------------------------------");
          println("drawTerrain: MountainGen - Peak Mountain Call");
          println("---------------------------------------------------------");
        
        } else if (elevation >= largeMountainThreshold) {
          PImage currentMountain = null;
          int subType = PApplet.parseInt(round(random(1, maxLMSubtype)));
          
          switch(subType) {
            case 1: 
              currentMountain = largeMountain1;
              break;
            case 2:
              currentMountain = largeMountain2;
              break;
            case 3:
              currentMountain = largeMountain3;
              break;
            case 4:
              currentMountain = largeMountain4;
              break;
          }
          
          placeMountain(currentMountain, maxLMOverlap, elevation, x, y);
          
          println("\n---------------------------------------------------------");
          println("drawTerrain: MountainGen - Large Mountain Call");
          println("---------------------------------------------------------");
          
        } else if (elevation >= mediumMountainThreshold) {
          PImage currentMountain = null;
          int subType = PApplet.parseInt(round(random(1, maxMMSubtype)));
          
          switch(subType) {
            case 1: 
              currentMountain = mediumMountain1;
              break;
            case 2:
              currentMountain = mediumMountain2;
              break;
            case 3:
              currentMountain = mediumMountain3;
              break;
            
          }
          
          placeMountain(currentMountain, maxMMOverlap, elevation, x, y);
          
          println("---------------------------------------------------------");
          println("drawTerrain: MountainGen - Medium Mountain Call");
          println("---------------------------------------------------------");
          
        } else if (elevation >= smallMountainThreshold && elevation <= mediumMountainThreshold) {
          PImage currentMountain = null;
          int subType = PApplet.parseInt(round(random(1, maxSMSubtype)));
          
          switch(subType) {
            case 1: 
              currentMountain = smallMountain1;
              break;
            case 2:
              currentMountain = smallMountain2;
              break;
            case 3:
              currentMountain = smallMountain3;
              break;
          }
          
          placeMountain(currentMountain, maxSMOverlap, elevation, x, y);

          println("---------------------------------------------------------");
          println("drawTerrain: MountainGen - Small Mountain Call");
          println("---------------------------------------------------------");
        } 
        
        // --- Treeline Generation ---
        
        // --  Low Mountain Treeline --
        if (noiseVal > 0.60f && noiseVal < 0.62f) {
          PImage currentTree = null;
          
          float startRange = 0.6f;
          float endRange = 0.62f;
          
          int subType = PApplet.parseInt(round(random(1, maxSTSubtype)));
          float overlapCalc = random(maxSTMOverlap - 0.25f, maxSTMOverlap + 0.2f);
         
          switch(subType) {
            case 1: 
              currentTree = smallTree1;
              break;
            case 2:
              currentTree = smallTree2;
              break;
            case 3:
              currentTree = smallTree3;
              break;
          }
          placeTree(currentTree, overlapCalc, x, y, startRange, endRange, noiseVal);
        }    
      }
      
      // Mid Land Tree Range -- NEEDS WORK TOMORROW
      if (noiseVal > 0.545f && noiseVal < 0.565f) {
        PImage currentTree = null;
          
        float startRange = 0.545f;
        float endRange = 0.56f;
        
        float overlapCalc;
        
        if (noiseVal > endRange - 0.05f) {
          currentTree = largeTree1;
          overlapCalc = random(maxLTOverlap - 0.2f, maxLTOverlap + 0.3f);
        } else if (noiseVal > startRange + 0.35f) {
          currentTree = mediumTree1;
          overlapCalc = random(maxMTOverlap - 0.1f, maxMTOverlap + 0.5f);
        } else {
          currentTree = smallTree1;
          overlapCalc = random(maxSTOverlap - 0.1f, maxSTOverlap + 0.6f);
        }
        
        placeTree(currentTree, overlapCalc, x, y, startRange, endRange, noiseVal);
        //terrain.set(x, y, debugColour1);
      }
      
      // --- Sea Generation ---
      if (noiseVal < terrainScale && noiseVal > noiseMin) {
        int blendedColor = lerpColor(deepWaterCol, shallowWaterCol, colorFactor);
        deepSea.set(x, y, blendedColor);
        seaMap.add(new PVector(x, y));
      }
      
      if (noiseVal < noiseMin * 1.2f) {
        //seaDangerMap.add(new PVector(x, y));
        //color blendedColor = lerpColor(debugColour1, debugColour3, colorFactorDangerous * 3.0f);
        //dangerousSea.set(x, y, debugColour1);
      }
    }
  }
  
  terrain.endDraw();
  terrainOutline.endDraw();
  shallowWater.endDraw();
  deepSea.endDraw();
  dangerousSea.endDraw();
  
  //decideThreat();
}


/**********************************
---- Noise & Utility Functions ----
*//////////////////////////////////


// Octave Noise - Function for generating additional fractal noise ontop of Perlin noise
public float octaveNoise(float x, float y, int octaves, float persistence, float lacunarity) {
  float total = 0;  // Float - Return total
  float frequency = 1; // Float - Frequency of varience
  float amplitude = 1; // Float - Amplitude
  float maxValue = 0; // //Float - Max Value (Used for normalizing)

  for (int i = 0; i < octaves; i++) {
    total += noise(x * frequency, y * frequency) * amplitude;
    maxValue += amplitude;
    amplitude *= persistence;
    frequency *= lacunarity;
  }
  return total / maxValue;
}

// Get Neighbours - Gets and checks nearby neighbouring cells, used for border checking mostly in system
public ArrayList<PVector> getNeighbours(int x, int y) {
  ArrayList<PVector> neighbours = new ArrayList<PVector>();
  for (int i = -1; i <= 1; i++) {
    for (int j = -1; j <= 1; j++) {
      if (i == 0 && j == 0) continue;
      int newX = x + i;
      int newY = y + j;
      if (newX >= 0 && newX < mapWidth && newY >= 0 && newY < mapHeight) {
        neighbours.add(new PVector(newX, newY));
      }
    }
  }
  return neighbours;
}


/********************************
---- Terrain Check Functions ----
*////////////////////////////////


// Calculate Coast Distance - Logic function for checking current cell's distance from the nearest coastal tile.
public float calculateCoastDistance(int x, int y) {
  float minDistance = Float.MAX_VALUE;

  for (int i = -searchRadius; i <= searchRadius; i++) {
    for (int j = -searchRadius; j <= searchRadius; j++) {
      int newX = x + i;
      int newY = y + j;
      if (newX >= 0 && newX < mapWidth && newY >= 0 && newY < mapHeight) {
        if (noiseMap[newX][newY] <= 0.6f && hasWaterNeighbour(newX, newY, mapWidth, mapHeight)) { 
          float distance = dist(x, y, newX, newY);
          minDistance = min(minDistance, distance);
        }
      }
    }
  }
  return minDistance;
}

// Has Water Neighbour - Function for checking if direct neighbour is a water tile
public boolean hasWaterNeighbour(int x, int y, int mapWidth, int mapHeight) {
  ArrayList<PVector> neighbours = getNeighbours(x, y);
  coastal = false;
  for (PVector neighbour : neighbours) {
    int nx = (int) neighbour.x;
    int ny = (int) neighbour.y;
    if (noiseMap[nx][ny] <= 0.5f) {
      if (nx == 0 || nx == mapWidth - 1 || ny == 0 || ny == mapHeight - 1) {
        coastal = true;
        break;
      }
      ArrayList<PVector> landNeighbours = getNeighbours(nx, ny);
      boolean foundLand = false;
      for (PVector landNeighbour : landNeighbours) {
        int lnX = (int) landNeighbour.x;
        int lnY = (int) landNeighbour.y;
        if (noiseMap[lnX][lnY] > 0.5f) {
          foundLand = true;
          break;
        }
      }
      if (foundLand) {
        coastal = true;
        break;
      }
    }
  }
  return coastal;
}

// Get Elevation Max - Function for determining highest elevation point on a generated noiseset 
public void getElevationLimits() {
  for (int x = 0; x < mapWidth; x++) {
    for (int y = 0; y < mapHeight; y++) {
      noiseMap[x][y] = octaveNoise(x * noiseScale, y * noiseScale, octaves, persistence, lacunarity);
      if (noiseMap[x][y] > terrainMaxElevation) {
        terrainMaxElevation = noiseMap[x][y];
      }
      if (noiseMap[x][y] < terrainMinElevation) {
        terrainMinElevation = noiseMap[x][y];
      }
    }
  }

  println("---------------------------------------------------------");
  println("getElevationLimits: Elevation Max: " + terrainMaxElevation);
  println("getElevationLimits: Elevation Max: " + terrainMinElevation);
  println("---------------------------------------------------------");
}

// Get Thresholds - Calculate mountainThresholds based on fitness values and elevation
public void getThresholds() {
  peakMountainThreshold = terrainMaxElevation + peakMountainChance;        // Spawn Chance - Peak Mountain Threshold
  largeMountainThreshold = terrainMaxElevation * largeMountainChance;      // Spawn Chance - Large Mountain
  mediumMountainThreshold = terrainMaxElevation * mediumMountainChance;    // Spawn Chance - Medium Mountain
  smallMountainThreshold = terrainMaxElevation * smallMountainChance;      // Spawn Chance - Small Mountain
}
/*********************
---- Code Section ----
*/////////////////////


// treeGen - Class Definition
class treeGen {
  PVector position;   // PVector - x, y position.
  PImage image;       // PImage - Stored image/tree type.

  treeGen(PVector position, PImage image) {
    this.position = position;
    this.image = image;
  }
}

// Place Tree - Function for preparing and storing trees depending on call circumstances.
public void placeTree(PImage image, float overlap, int x, int y, float startRange, float endRange, float noiseVal) {
  
  boolean canSpawnTree = true;
  for (treeGen tree : trees) {
    float distance = dist(x, y, tree.position.x, tree.position.y);
    float minDistance = (tree.image.width + tree.image.height) / 2 * overlap;
    
    if (distance < minDistance) {
      canSpawnTree = false;
      println("TreeGen: Error! Cannot Place " + tree.toString() + " at " + x + ", " + y + ". Distance: " + distance + " MinDistance: " + minDistance);
      break;
    }
  }
  
  PImage imgCopy = image.copy();
  float elevationCheckWidth = map(noiseVal, startRange, endRange, 0.95f, 1.1f); 
  float elevationCheckHeight = map(noiseVal, startRange, endRange, 0.85f, 1.1f); 
  
  int newWidth = PApplet.parseInt(imgCopy.width * elevationCheckWidth);
  int newHeight = PApplet.parseInt(imgCopy.height * elevationCheckHeight);
  int newTransparency = PApplet.parseInt(map(noiseVal, startRange, endRange, 190, 0));

  imgCopy.resize(newWidth, newHeight);
  tint(255, newTransparency);

  // PVector Array Storage - x & y represent the related co-ordinates, z represents mountain type.
  if (canSpawnTree) {
   trees.add(new treeGen(new PVector(x, y), imgCopy));
   println("TreeGen: Successfully placed at " + x + ", " + y);
  }
}
/*********************
---- Code Section ----
*/////////////////////

// ZoneGen - Class Definition
class ZoneGen {
  int zoneWidth;
  int zoneHeight;
  PVector position;
  boolean coastCheck;
  PImage type;
  boolean ruinsCheck;
  boolean churchCheck;
  boolean towerCheck;
  
  ZoneGen(int zoneWidth, int zoneHeight, PVector position, boolean coastCheck, PImage type, boolean ruinsCheck, boolean churchCheck, boolean towerCheck) {
    this.zoneWidth = zoneWidth;
    this.zoneHeight = zoneHeight;
    this.position = position;
    this.coastCheck = coastCheck;
    this.type = type;
    this.ruinsCheck = ruinsCheck;
    this.churchCheck = churchCheck;
    this.towerCheck = towerCheck;
  }
}

// Select Strategic Points
public void selectStrategicPoints() {
  println("selectStrategicPoints: Checking Points...");
  
  int[][] landZoneSizes = {{70, 30}, {40, 25}, {20, 20}};
  //int[][] seaZoneSizes = {{100, 60}, {70, 40}, {40, 30}};
  
  for (int[] size : landZoneSizes) {
    int zoneWidth = size[0];
    int zoneHeight = size[1];

    // Loop over the terrainMap instead of the entire map
    for (int i = 0; i < terrainMap.size(); i += 2) {
      PVector point = terrainMap.get(i);
      int x = (int) point.x;
      int y = (int) point.y;
      if (x > width || y > height) {
        continue;
      }
      
      boolean isCoastal = isNearCoast(x, y);
      boolean isRuins = false;
      boolean isChurch = false;
      boolean isTower = false;
      int zoneTypeRand = round(random(1, 3));
      
      // Verify if the point is on a suitable spot on the terrain
      if (isSuitableSpot(x, y, zoneWidth, zoneHeight) && (!isCoastal || coastalZoneCount < minimumCoastalZones)) {
        if (isCoastal) {
          coastalZoneCount++;
        }
        
        // Small Zone Handling
        if (zoneTypeRand == 3 && smallZoneCount < maxSmallZones) {
          PImage currentSpawn = null;               // Variable for current used spawn/image ID
          
          float ruinsChance = random(0, 1); // Random float for ruins spawn chance
          float ruinsThreshold = random(0.5f, 1); // Random float for ruins spawn chance
          
          if (ruinsChance > ruinsThreshold) {
            ruinsCount++;
            isRuins = true;
            int ruinsType = PApplet.parseInt(round(random(1, 5)));
            switch(ruinsType) {
            
              // Ruins Selection
            case 1: 
              currentSpawn = ruins1;
              break;
            case 2:
              currentSpawn = ruins2;
              break;
            case 3:
              currentSpawn = ruins3;
              break;
            case 4:
              currentSpawn = ruins4;
              break;
            case 5:
              currentSpawn = ruins5;
              break;
            }
          } 
          
          // Small Zone Selection
          else {
            int zoneType = PApplet.parseInt(round(random(1, 4)));
            switch(zoneType) {
            
            case 1:
              currentSpawn = smallChurch;
              isChurch = true;
              break;
            case 2:
              currentSpawn = wizardTower;
              isTower = true;
              break;
           
            case 3:
              currentSpawn = watchTower;
              isTower = true;
              break;
           
            case 4:
              currentSpawn = guardTower;
              isTower = true;
              break;
            }
          }
          
          
          strategicZones.add(new ZoneGen(zoneWidth, zoneHeight, new PVector(x, y), isCoastal, currentSpawn, isRuins, isChurch, isTower));
          finalStrategicPoints.add(new PVector(x, y));
          smallZoneCount++;
          totalZones++;
        } 
        
        // Large Zone Handling - Priority for city spawn behind map landmarks (small) // fix town
        else if (zoneTypeRand == 1 && largeZoneCount < maxLargeZones) {
          PImage currentSpawn = null;               // Variable for current used spawn/image ID
          switch(raceType) {
            case 1:
              currentSpawn = humanTown;
              break;
            case 2:
              currentSpawn = halflingTown;
              break;
            case 3:
              currentSpawn = dwarfTown;
              break;
            case 4:
              currentSpawn = elfTown;
              break;
          }
          strategicZones.add(new ZoneGen(zoneWidth, zoneHeight, new PVector(x, y), isCoastal, currentSpawn, isRuins, isChurch, isTower));
          finalStrategicPoints.add(new PVector(x, y));
          
          largeZoneCount++;
          totalZones++;
        } 
        
        // Medium Zone Handling
        else if (zoneTypeRand == 2 && mediumZoneCount < maxMediumZones) {
          PImage currentSpawn = null;               // Variable for current used spawn/image ID
          int zoneType = PApplet.parseInt(round(random(1, 3)));
          switch(zoneType) {
            case 1:
              currentSpawn = mediumVillage1;
              break;
            case 2:
              currentSpawn = mediumVillage2;
              break;
            case 3:
              currentSpawn = mediumVillage3;
              break;
          }
          strategicZones.add(new ZoneGen(zoneWidth, zoneHeight, new PVector(x, y), isCoastal, currentSpawn, isRuins, isChurch, isTower));
          finalStrategicPoints.add(new PVector(x, y));
          mediumZoneCount++;
          totalZones++;
        }
        
      }
    }
  }
}

// Is Suitable Spot - Verifies strategic spots based on three factors: placement, proximity to strategic landmarks (coast, trees or mountains) & overlap calculation
public boolean isSuitableSpot(int x, int y, int zoneWidth, int zoneHeight) {
  // Verify terrain type and avoid coast or other objects
  for (int i = 0; i < zoneWidth; i++) {
    for (int j = 0; j < zoneHeight; j++) {
      
      if (x + i >= mapWidth || y + j >= mapHeight) {
        return false; // The point is outside the map, so it's not suitable
      }
      
      if (noiseMap[x + i][y + j] <= terrainScale || hasWaterNeighbour(x + i, y + j, mapWidth, mapHeight)) {
        return false; // The point is on the coast or water, so it's not suitable
      }
    }
  }

  // Check for overlaps with other terrain objects
  if (isOverlappingWithTerrainObject(x, y, zoneWidth, zoneHeight)) {
    return false; // The point is overlapping with another terrain object, so it's not suitable
  }
  
  // Check if the point is close to the coast, a mountain, or a tree
  if (!isNearCoast(x, y) && !isNearMountainOrTree(x, y, zoneWidth, zoneHeight)) {
    return false; // The point is not near a coast, mountain, or tree, so it's not suitable
  }
  
  // Check for overlaps with other strategic points
  for (PVector point : finalStrategicPoints) {
    if (dist(x, y, point.x, point.y) < minDistanceBetweenPoints) {
      return false; // The point is too close to another strategic point, so it's not suitable
    }
  }
  
  for (ZoneGen zone : strategicZones) {
    if (x >= zone.position.x && x <= zone.position.x + zone.zoneWidth &&
        y >= zone.position.y && y <= zone.position.y + zone.zoneHeight) {
      return false; // The point is within another strategic zone, so it's not suitable
    }
  }
  
  println("isSuitableSpot: Strategic Point Identified at " + x + ", " + y);
  return true; // The point is suitable
}


// Is Near Coast - Internal call function for calculateCoastDistance (terrainGen)
public boolean isNearCoast(int x, int y) {
  return calculateCoastDistance(x, y) <= cityCoastProximity;
}


// Is Near Mountain of Tree - Overlap Check function for mountain and trees specifically in reference to zones.
public boolean isNearMountainOrTree(int x, int y, int zoneWidth, int zoneHeight) {
  // Check if there's a mountain or tree within a certain distance
  for (mountainGen mountain : mountains) {
    if (dist(x, y, mountain.position.x, mountain.position.y) < Math.max(zoneWidth, zoneHeight)) {
      return true;
    }
  }
  
  for (treeGen tree : trees) {
    if (dist(x, y, tree.position.x, tree.position.y) < Math.max(zoneWidth, zoneHeight)) {
      return true;
    }
  }

  return false;
}

// Draw Strategic Points - Function for drawing strategic zones (cities, towns and landmark generation)
public void drawStrategicPoints(int raceType) { // adjust for zone type spawning / naming then done 
  
  boolean isChurch = false;
  boolean isRuins = false;
  boolean isTower = false;
  PImage borderBG;

  terrain.beginDraw();// Call begin draw for drawing stategic zone images (towns, ruins, etc)
  
  if (strategicZones.size() == 0) {
    println("drawStrategicZones: No Zones Available, returning..");
    return;
  }
  // Loop over generated zones
  for (ZoneGen zone : strategicZones) {
    
    
    String zoneName = ""; // String - Zone Name Storage
    float textY = zone.position.y;
    
    // Capital Name Storage / Large Zone Check
    if (zone.zoneWidth == 70) {
      zoneName = generateTownName(raceType, hostility, zone.coastCheck, isChurch, isRuins, isTower); 
      switch(raceType) {
        case 1:
          zone.type = humanTown;
          break;
        case 2:
          zone.type = halflingTown;
          break;
        case 3:
          zone.type = dwarfTown;
          break;
        case 4:
          zone.type = elfTown;
          break;
      }
      capitalName = zoneName;
    } 
    
    if (zone.zoneWidth == 40) {
      zoneName = generateTownName(raceType, hostility, zone.coastCheck, isChurch, isRuins, isTower); 
      int zoneType = PApplet.parseInt(round(random(1, 3)));
      
      switch(zoneType) {
        case 1:
          zone.type = mediumVillage1;
          break;
        case 2:
          zone.type = mediumVillage2;
          break;
        case 3:
          zone.type = mediumVillage3;
          break;
        
      }
    } 
    
    terrain.image(zone.type, zone.position.x, zone.position.y);
    // Church Check
    if (zone.churchCheck) {
      isChurch = true;
      zoneName = generateTownName(raceType, hostility, zone.coastCheck, isChurch, isRuins, isTower);
    } 
    
    // Ruins Check
    if (zone.ruinsCheck) {
      isRuins = true;
      borderBG = ruinsBG;
      zoneName = generateTownName(raceType, hostility, zone.coastCheck, isChurch, isRuins, isTower);
    } else {
      borderBG = zoneNameBorder;
    }
    
    // Tower Check
    if (zone.towerCheck) {
      isTower = true;
      zoneName = generateTownName(raceType, hostility, zone.coastCheck, isChurch, isRuins, isTower);
    } else {
      borderBG = zoneNameBorder;
    }
    // Text Image Definition - Town Name
    
    
    
    
    // Zone Positioning
    textY = zone.position.y + 3;

    if (zoneName == "") {
      zoneNullCount++;
      zoneName = generateTownName(raceType, hostility, zone.coastCheck, isChurch, isRuins, isTower); // get names working correctly
    }
    
    terrain.fill(0); // Text Colour Fill
    
    float textWidth = terrain.textWidth(zoneName);
    float textX = zone.position.x + (zone.zoneWidth / 2) - (textWidth / 2) ;
    int textPadding = 5; // Adjust this value to move text and border further from the zone
    
    terrain.image(borderBG, textX - 2, textY - 10 - textPadding, textWidth + 4, 12); // Add 4 to account for the 2 pixel padding on each side
    terrain.text(zoneName, textX, textY - textPadding); // map string length to use for scale of image
  }
  terrain.endDraw();
}

// Terrain Overlap Check - Local zone overlap function, checks overlap against other zones anmd terrain objects.
public boolean isOverlappingWithTerrainObject(int x, int y, int zoneWidth, int zoneHeight) {
  int mountainSize = largeMountain1.width; // Use Large Mountain Overlap to Ensure no bounding issues
  int treeSize = largeTree1.width; // Use Large Tree Overlap to Ensure no bounding issues
  
  // Overlap Check - Zones
  for (ZoneGen zone : strategicZones) {
    if (x < zone.position.x + zone.zoneWidth &&
        x + zoneWidth > zone.position.x &&
        y < zone.position.y + zone.zoneHeight &&
        y + zoneHeight > zone.position.y) {
      println("drawStrategicPoints: Overlapping with another strategic zone at " + x + ", " + y);
      return true;
    }
  }
  
  // Overlap Check - Mountains
  for (mountainGen mountain : mountains) {
    if (x < mountain.position.x + mountainSize &&
        x + zoneWidth > mountain.position.x &&
        y < mountain.position.y + mountainSize &&
        y + zoneHeight > mountain.position.y) {
      return true; 
    }
  }

  // Overlap Check - Trees
  for (treeGen tree : trees) {
    if (x < tree.position.x + treeSize &&
        x + zoneWidth > tree.position.x &&
        y < tree.position.y + treeSize &&
        y + zoneHeight > tree.position.y) {
      return true;
    }
  }
  return false;
}


  public void settings() { size(1200, 1000); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "fantasyGenMain" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
